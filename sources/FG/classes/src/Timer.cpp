//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  Project : Function Generator
//  @ File Name : Timer.cpp
//  @ Date : 2015/05/25
//  @ Author : Kazuki Kikuchi
//
//


#include "Timer.hpp"
#include "Settings.hpp"
#include "sfr_r829.h"



class INTRclass{
public:
	INTRbase *ib;
	void run(){
		ib->op();
	}
};

INTRclass intrcls;

Timer::Timer()
	:m_tmp(0)
{
	//割り込み禁止
	asm("FCLR I");

	//TIMERBをストップ
	tstart_trbcr = 0;
	while (tcstf_trbcr != 0); //実際にカウントがとまるまで待つ

	//タイマBの割り込みを禁止
	trbic = 0x00;
	//TRBPREレジスタ、TRBSCレジスタ、TRBPRレジスタ、TSTARTビット、TCSTFビット、TRBOCRレジスタのTOSSTFビット
	//をリセット
	tstop_trbcr = 1;

	//タイマモード設定 図１４．１４
	topl_trbioc = 0;
	tocnt_trbioc = 0;
	inostg_trbioc = 0;
	inoseg_trbioc = 0;

	//タイマモードに設定
	tmod0_trbmr = 0;
	tmod1_trbmr = 0;
	//レジスタ書き込み制御 リロードレジスタ、カウンタへの書き込みを許可
	twrc_trbmr = 0;
	//クロックソースF１選択
	tck0_trbmr = 0;
	tck1_trbmr = 0;
	//タイマへカウントソースを供給
	tckcut_trbmr = 0;

}
//割り込み間隔は5usが最小だった
//8bitカウンタだと12.8usが最大
void Timer::SetDt(float dt_us) {
	float dt_count_soruce;
	float dt_count_source_inv;
	unsigned char clksrc_div_coeff = 0;

	//float dt_max = 12.8;
	//float dt_div_coeff = dt_us % dt_max;

	if ((tck0_trbmr == 0) && (tck1_trbmr == 0)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
		dt_count_source_inv = (float) Settings::CLOCK_MAIN_HZ;
	}
	else if ((tck0_trbmr == 0) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 8.0;
		dt_count_source_inv = (float) Settings::CLOCK_MAIN_HZ / 8.0;
	}
	else if ((tck0_trbmr == 1) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 2.0;
		dt_count_source_inv = (float) Settings::CLOCK_MAIN_HZ / 2.0;
	}
	else{
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
		dt_count_source_inv = (float) Settings::CLOCK_MAIN_HZ;
	}

	//ちょうどいい分周比を見つける
	//普通にあまりを見つける実装でいいと思う

	while (1){
		m_tmp_count = (unsigned int) 
			((dt_us * dt_count_source_inv / (float)(clksrc_div_coeff + 1)) / 1000000.0);
		if ((unsigned int)m_tmp_count < 256){
			break;
		}
		clksrc_div_coeff++;
	}

	//m_tmp_count = (unsigned int) ((dt_us * dt_count_source_inv) / 1000000.0);
	//m_tmp_pre = (unsigned char)((m_tmp_count & 0xFF00) >> 7);
	//m_tmp_pr = (unsigned char) (m_tmp_count & 0x00FF);

	m_tmp_pre = clksrc_div_coeff;
	m_tmp_pr = (unsigned char)m_tmp_count;


	//trbprが０だと割り込みが起きないので０のときは１にしておく
	if (m_tmp_pr == 0){
		m_tmp_pr = 1;
	}

	//プリスケーラ
	trbpre = m_tmp_pre;
	//trbpr = (unsigned char)(dt_us / 1000000.0 / dt_count_soruce);
	trbpr = m_tmp_pr;//(unsigned char) ((dt_us * dt_count_source_inv) / 1000000.0);

	

}

float Timer::GetDt(){
	float dt_count_soruce;
	if ((tck0_trbmr == 0) && (tck1_trbmr == 0)){
		dt_count_soruce = 1.0 / (float)Settings::CLOCK_MAIN_HZ;
	}else if ((tck0_trbmr == 0) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 8.0;
	}else if ((tck0_trbmr == 1) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 2.0;
	} else{
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
	}

	return (float)(trbpre + 1) * (float)(trbpr + 1) * dt_count_soruce;

}

float Timer::SGetDt(){
	float dt_count_soruce;
	if ((tck0_trbmr == 0) && (tck1_trbmr == 0)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
	}
	else if ((tck0_trbmr == 0) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 8.0;
	}
	else if ((tck0_trbmr == 1) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 2.0;
	}
	else{
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
	}

	return (float) (trbpre + 1) * (float) (trbpr + 1) * dt_count_soruce;
}


void Timer::Enable() {
	//割り込み許可 マスカブル最上位権限
	ilvl0_trbic = 1;
	ilvl1_trbic = 1;
	ilvl2_trbic = 1;

	tstart_trbcr = 1;
	while (tcstf_trbcr != 1);

	//割り込み許可
	asm("FSET I");
}

void Timer::Disable() {
	tstart_trbcr = 0;
	while (tcstf_trbcr != 0);
}

void Timer::SetInterrupter(void (*op)()){
	//intrcls.op  = op;
}

void Timer::SetClassInterrupter(INTRbase * pib){
	intrcls.ib = pib;
}

#pragma INTERRUPT t_intr_test (vect=24)
void t_intr_test(){
	intrcls.run();
}


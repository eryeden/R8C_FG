//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  Project : Function Generator
//  @ File Name : Timer.cpp
//  @ Date : 2015/05/25
//  @ Author : Kazuki Kikuchi
//
//


#include "Timer.hpp"
#include "Settings.hpp"
#include "sfr_r829.h"

Timer::Timer()
	: m_dac(),
	  m_tmp(0)
{
	//割り込み禁止
	asm("FCLR I");

	//TIMERBをストップ
	tstart_trbcr = 0;
	while (tcstf_trbcr != 0); //実際にカウントがとまるまで待つ

	//タイマBの割り込みを禁止
	trbic = 0x00;
	//TRBPREレジスタ、TRBSCレジスタ、TRBPRレジスタ、TSTARTビット、TCSTFビット、TRBOCRレジスタのTOSSTFビット
	//をリセット
	tstop_trbcr = 1;

	//タイマモード設定 図１４．１４
	topl_trbioc = 0;
	tocnt_trbioc = 0;
	inostg_trbioc = 0;
	inoseg_trbioc = 0;

	//タイマモードに設定
	tmod0_trbmr = 0;
	tmod1_trbmr = 0;
	//レジスタ書き込み制御 リロードレジスタ、カウンタへの書き込みを許可
	twrc_trbmr = 0;
	//クロックソースF１選択
	tck0_trbmr = 0;
	tck1_trbmr = 0;
	//タイマへカウントソースを供給
	tckcut_trbmr = 0;

}

void Timer::SetDt(float dt_us) {
	float dt_count_soruce;
	if ((tck0_trbmr == 0) && (tck1_trbmr == 0)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
	}
	else if ((tck0_trbmr == 0) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 8.0;
	}
	else if ((tck0_trbmr == 1) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 2.0;
	}
	else{
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
	}
	//プリスケーラ
	trbpre = 0;
	trbpr = dt_us / 1000000.0 / dt_count_soruce;

}

float Timer::GetDt(){
	float dt_count_soruce;
	if ((tck0_trbmr == 0) && (tck1_trbmr == 0)){
		dt_count_soruce = 1.0 / (float)Settings::CLOCK_MAIN_HZ;
	}else if ((tck0_trbmr == 0) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 8.0;
	}else if ((tck0_trbmr == 1) && (tck1_trbmr == 1)){
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ * 2.0;
	} else{
		dt_count_soruce = 1.0 / (float) Settings::CLOCK_MAIN_HZ;
	}

	return (float)(trbpre + 1) * (float)(trbpr + 1) * dt_count_soruce;

}

void Timer::Enable() {
	//割り込み許可 マスカブル最上位権限
	ilvl0_trbic = 1;
	ilvl1_trbic = 1;
	ilvl2_trbic = 1;

	tstart_trbcr = 1;
	while (tcstf_trbcr != 1);

	//割り込み許可
	asm("FSET I");
}

void Timer::Disable() {
	tstart_trbcr = 0;
	while (tcstf_trbcr != 0);
}

volatile void Timer::IntrTB(){
	m_tmp = (m_tmp > (0x0FFF - 1)) ? 0 : m_tmp + 500;
	m_dac.WriteVoltageA(m_tmp);
}